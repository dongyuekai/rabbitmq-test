首先本地需要拉取一个rabbitmq的镜像，跑起来，然后映射容器内的5672和15672这俩端口到本地的端口
15672是管理界面的 5672是mq服务的端口

![alt text](/public/mq原理.jpg)

### rabbitmq解决了什么问题

+ 流量削峰：可以把很大的流量放到mq种按照一定的流量上限来慢慢消费，这样虽然慢一点，但不至于崩溃
+ 应用解耦：应用之间不再直接依赖，就算某个应用挂掉了，也可以在恢复后从mq中消费消息，并不会一个应用挂掉了，它关联的应用也挂掉。

比如前端监控系统的后端服务，就很适合使用mq来做流量削峰。

前端监控系统会收到很多来自用户端的请求，如果直接存入数据库很容易把数据库服务搞挂掉，所以一般会加一个mq来缓冲。

它是生产者往 queue 里放入消息，消费者从里面读消息，之后确认消息收到的流程。

当一对多的时候，还要加一个 Exchange 交换机来根据不同的规则转发消息：

* direct 交换机：根据 routing key 转发消息到队列
* topic 交换机：根据 routing key 转发消息到队列，支持模糊匹配
* headers 交换机：根据 headers 转发消息到队列
* fanout 交换机：广播消息到交换机下的所有队列

RabbitMQ 在后端系统中经常能见到，是很常用的中间件。


